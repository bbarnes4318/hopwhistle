#!KAMAILIO
#!define WITH_PGSQL
#!define WITH_AUTH
#!define WITH_IPAUTH
#!define WITH_USRLOCDB
#!define WITH_NAT
#!define WITH_TLS
#!define WITH_ANTIFLOOD
#!define WITH_BLOCKLIST
#!define WITH_TOPOH
#!define WITH_PIKE
#!define WITH_DISPATCHER
#!define WITH_HTTP_ASYNC_CLIENT

####### Global Parameters #########

# Logging
debug=3
log_stderror=no
log_facility=LOG_LOCAL0

# Network settings
listen=udp:0.0.0.0:5060
listen=tcp:0.0.0.0:5060
#listen=tls:0.0.0.0:5061

# IP aliases (if needed)
#alias=example.com

# Ports
#port=5060

# DNS
dns=no
dns_try_ipv6=no
rev_dns=no

# # SIP timers
# fr_timer=9
# fr_inv_timer=120
# wt_timer=5

# Topology hiding
# topoh_hiding=1
# #
# Anti-fraud and security
# enable_blacklist=1
# enable_whitelist=1

####### Modules #########

loadmodule "sl.so"
loadmodule "tm.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "textops.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "ctl.so"
loadmodule "cfgutils.so"
loadmodule "acc.so"
# loadmodule "nathelper.so"
loadmodule "rtpproxy.so"
loadmodule "dispatcher.so"
loadmodule "htable.so"
loadmodule "pike.so"
loadmodule "topoh.so"
loadmodule "permissions.so"
loadmodule "rtimer.so"
# loadmodule "http_async_client.so"
# loadmodule "db_postgres.so"
# loadmodule "auth_db.so"
# loadmodule "usrloc.so"

# TLS (optional)
#loadmodule "tls"

####### Module Parameters #########

# Dispatcher - FreeSWITCH cluster
# Load from file: /etc/kamailio/dispatcher.list
modparam("dispatcher", "list_file", "/etc/kamailio/dispatcher.list")
modparam("dispatcher", "ds_ping_interval", 30)
modparam("dispatcher", "ds_ping_method", "OPTIONS")
modparam("dispatcher", "ds_probing_mode", 1)
modparam("dispatcher", "ds_ping_from", "sip:kamailio@$${local_ip}")
modparam("dispatcher", "ds_ping_reply_codes", "200,403")
modparam("dispatcher", "ds_inactive_threshold", 3)
# modparam("dispatcher", "ds_active_threshold", 1)
modparam("dispatcher", "ds_probing_threshold", 1)

# Pike - Rate limiting
modparam("pike", "sampling_time_unit", 2)
modparam("pike", "reqs_density_per_unit", 16)
modparam("pike", "remove_latency", 4)

# Topology hiding
modparam("topoh", "mask_key", "topoh_mask")
# modparam("topoh", "server_hiding", 1)
# modparam("topoh", "via1_mode", 1)
modparam("topoh", "callid_prefix", "CF-")

# NAT helper
#modparam("nathelper", "natping_interval", 30)
#modparam("nathelper", "ping_nated_only", 1)
#modparam("nathelper", "sipping_bflag", 1)
#modparam("nathelper", "sipping_from", "sip:kamailio@$${local_ip}")

# RTPProxy
#modparam("rtpproxy", "rtpproxy_sock", "udp:rtpengine:22222")

# Permissions
# modparam("auth_db", "db_url", "$ENV(DB_URL)")
# modparam("usrloc", "db_url", "$ENV(DB_URL)")
# modparam("auth_db", "calculate_ha1", 1)
# modparam("auth_db", "password_column", "password")
# modparam("auth_db", "user_column", "username")
# modparam("auth_db", "domain_column", "domain")
#
# Enable database authentication
# modparam("auth_db", "load_credentials", "$avp(creds)")

# HTTP async client (for API calls)
# modparam("http_async_client", "workers", 4)
# modparam("http_async_client", "timeout", 5)

# Sanity checks
modparam("sanity", "default_checks", 1)

# Max forward
modparam("maxfwd", "max_limit", 70)

# ACC - Accounting
modparam("acc", "early_media", 0)
modparam("acc", "report_ack", 0)
modparam("acc", "report_cancels", 0)
modparam("acc", "detect_direction", 1)

####### Routing Logic ########

# Main request routing
# # route[REQUEST] {
# #     # Per-request initial checks
# #     route(REQINIT);
# # }

# # Per SIP request initial checks
# # route[REQINIT] {
# #     # Sanity checks
# #     if (!sanity_check("1511", "7")) {
# #         xlog("L_WARN", "Malformed SIP message from $si:$sp\n");
# #         exit;
# #     }
# #
# #     # Max forward check
# #     if (!mf_process_maxfwd_header("10")) {
# #         sl_send_reply("483", "Too Many Hops");
# #         exit;
# #     }
# #
# #     # Record routing for stateful processing
# #     if (is_method("INVITE|UPDATE")) {
# #         if (!has_totag()) {
# #             record_route();
# #         }
# #     }
# #
# #     # Topology hiding - mask headers
# #     if (is_method("INVITE|UPDATE|REFER|SUBSCRIBE")) {
# #         # topoh_hide("hid");
# #         # # # # #
# #     }
# #
# #     # Unmask on responses
# #     if (is_reply()) {
# #         # # topoh_restore();
# #         route(REPLY);
# #         exit;
# #     }
# #
# #     # Handle CANCEL
# #     if (is_method("CANCEL")) {
# #         if (t_check_trans()) {
# #             t_reply("200", "OK");
# #         }
# #         exit;
# #     }
# #
# #     # Handle OPTIONS
# #     if (is_method("OPTIONS")) {
# #         route(OPTIONS_HANDLER);
# #         exit;
# #     }
# #
# #     # Rate limiting - Pike
# #     if (!pike_check_req()) {
# #         xlog("L_WARN", "Pike blocking $rm from $si:$sp\n");
# #         sl_send_reply("503", "Service Unavailable");
# #         exit;
# #     }
# #
# #     # DoS guard - mDNS/ICMP flood protection
# #     if ($rm == "REGISTER" || $rm == "INVITE")) {
# #         if ($si == "224.0.0.251" || $si == "ff02::fb") {
# #             xlog("L_WARN", "mDNS request blocked from $si\n");
# #             sl_send_reply("403", "Forbidden");
# #             exit;
# #         }
# #     }
# #
# #     # NAT detection
# #     route(NAT_DETECT);
# #
# #     # Per-tenant throttling (check API)
# #     route(TENANT_THROTTLE);
# #
# #     # Route based on method
# #     if (is_method("REGISTER")) {
# #         route(REGISTER);
# #         exit;
# #     }
# #
# #     if (is_method("INVITE")) {
# #         route(INVITE);
# #         exit;
# #     }
# #
# #     # Default: forward to FreeSWITCH
# #     route(FORWARD);
# # }

# # OPTIONS handler - health check
# # route[OPTIONS_HANDLER] {
# xlog("L_INFO", "OPTIONS request from $si:$sp to $ru\n");
#
# # Forward OPTIONS to FreeSWITCH cluster for health check
# route(FORWARD);
# }

# # NAT detection and handling
# # route[NAT_DETECT] {
# #     if (is_method("REGISTER")) {
# #         fix_nated_register();
# #         # setbflag(6); # NAT flag
# #     } else {
# #         if (check_route_param("nat=yes")) {
# #             # setbflag(6);
# #         }
# #         if (isflagset(NAT)) {
# #             # setbflag(6);
# #         }
# #     }
# #
# #     if (is_method("INVITE|UPDATE")) {
# #         if (has_body("application/sdp")) {
# #             if (nat_uac_test("19")) {
# #                 fix_nated_contact();
# #                 # setbflag(6);
# #                 # route(RTPPROXY);
# #             }
# #         }
# #     }
# # }

# # RTPProxy handling for NAT traversal
# # route[RTPPROXY] {
# #     if (is_method("INVITE")) {
# #         if (has_body("application/sdp")) {
# #             rtpproxy_manage("co");
# #         }
# #     } else if (is_method("BYE|CANCEL")) {
# #         # rtpproxy_unmanage();
# #     } else if (is_method("UPDATE")) {
# #         if (has_body("application/sdp")) {
# #             rtpproxy_manage("co");
# #         }
# #     }
# #     if (is_method("REGISTER")) {
# #         route(FORWARD);
# #     }
# # }
# route[RTPPROXY] {
#     if (is_method("INVITE")) {
#         if (has_body("application/sdp")) {
#             rtpproxy_manage("co");
#         }
#     }
#     if (is_method("REGISTER")) {
#         #         fix_nated_register();
#         route(FORWARD);
#     }
# }

# # Per-tenant throttling
# # route[TENANT_THROTTLE] {
# #     # Check X-Tenant-ID header from API
# #     $var(tenant_id) = $(hdr(X-Tenant-ID));
# #
# #     if ($var(tenant_id) != $null) {
# #         # Check tenant throttle limit from htable (populated by API)
# #         $var(limit) = $sht(tenant_throttle=>$var(tenant_id));
# #
# #         if ($var(limit) != $null && $var(limit) > 0) {
# #             # Check current count
# #             $var(count) = $sht(tenant_count=>$var(tenant_id));
# #
# #             if ($var(count) == $null) {
# #                 $sht(tenant_count=>$var(tenant_id)) = 1;
# #             } else {
# #                 $sht(tenant_count=>$var(tenant_id)) = $var(count) + 1;
# #             }
# #
# #             if ($sht(tenant_count=>$var(tenant_id)) > $var(limit)) {
# #                 xlog("L_WARN", "Tenant $var(tenant_id) throttle limit exceeded\n");
# #                 sl_send_reply("429", "Too Many Requests");
# #                 exit;
# #             }
# #         }
# #     }
# # }

# # REGISTER handling
# # route[REGISTER] {
# #     xlog("L_INFO", "REGISTER request from $fu at $si:$sp\n");
# #
# #     # Anti-fraud: Check blacklist
# #     if (check_blacklist("$si")) {
# #         xlog("L_WARN", "REGISTER from blacklisted IP $si\n");
# #         sl_send_reply("403", "Forbidden");
# #         exit;
# #     }
# #
# #     # Anti-fraud: Check whitelist (if configured)
# #     if (allow_source_address("1")) {
# #         xlog("L_INFO", "REGISTER from whitelisted IP $si\n");
# #     }
# #
# #     # Save location
# #     if (!save("location")) {
# #         sl_reply_error();
# #     }
# #
# #     exit;
# # }

# # INVITE handling
# # route[INVITE] {
# #     xlog("L_INFO", "INVITE request from $fu to $ru\n");
# #
# #     # Anti-fraud: Check blacklist
# #     if (check_blacklist("$si")) {
# #         xlog("L_WARN", "INVITE from blacklisted IP $si\n");
# #         sl_send_reply("403", "Forbidden");
# #         exit;
# #     }
# #
# #     # Anti-fraud: Validate From header
# #     if (!validate_from_header()) {
# #         xlog("L_WARN", "Invalid From header in INVITE\n");
# #         sl_send_reply("403", "Forbidden");
# #         exit;
# #     }
# #
# #     # Create transaction for stateful processing
# #     if (!t_newtran()) {
# #         sl_reply_error();
# #         exit;
# #     }
# #
# #     # Forward to FreeSWITCH
# #     route(FORWARD);
# # }

# # Forward to FreeSWITCH cluster
# # route[FORWARD] {
# #     # Use dispatcher to load balance across FreeSWITCH nodes
# #     if (!ds_select_dst("1", "0")) {
# #         xlog("L_ERR", "No FreeSWITCH nodes available\n");
# #         sl_send_reply("503", "Service Unavailable");
# #         exit;
# #     }
# #
# #     xlog("L_INFO", "Forwarding $rm to FreeSWITCH: $du\n");
# #
# #     # Forward request
# #     if (!t_relay()) {
# #         sl_reply_error();
# #     }
# # }

# # Reply handling
# # route[REPLY] {
# #     # Topology hiding - restore headers
# #     topoh_restore();
# #
# #     # NAT handling for replies
# #     if (isbflagset(6)) {
# #         fix_nated_contact();
# #     }
# #
# #     # RTPProxy handling
# #     if (has_body("application/sdp")) {
# #         rtpproxy_manage("co");
# #     }
# # }

# # Failure route
# # route[FAILURE] {
# #     if (t_check_status("3[0-9][0-9]")) {
# #         t_reply("404", "Not Found");
# #         exit;
# #     }
# # }

####### Local Routing Logic #######

# # Handle requests within the dialog
# # route[WITHINDLG] {
# #     if (!has_totag()) {
# #         sl_send_reply("404", "Not here");
# #         exit;
# #     }
# #
# #     # Route based on method
# #     if (is_method("BYE")) {
# #         route(FORWARD);
# #         exit;
# #     }
# #
# #     if (is_method("ACK")) {
# #         if (t_check_trans()) {
# #             t_reply("200", "OK");
# #             exit;
# #         }
# #         route(FORWARD);
# #         exit;
# #     }
# #
# #     route(FORWARD);
# # }

####### Error Handling #######

# # Handle errors
# # route[ERROR] {
# #     xlog("L_ERR", "Error handling: $err.class/$err.level/$err.info\n");
# #     sl_reply_error();
# # }

####### Event Routes #######

# # Timer route for cleanup
# # route[TIMER] {
# #     # Reset tenant counters periodically
# #     $sht(tenant_count=>*) = $null;
# # }

# # Startup route
# # route[STARTUP] {
# #     # Load dispatcher from file or database
# #     # Dispatcher list is loaded from /etc/kamailio/dispatcher.list
# #     # Or use: kamctl dispatcher reload
# #
# #     xlog("L_INFO", "Kamailio SBC started\n");
# #     xlog("L_INFO", "Loading dispatcher configuration\n");
# # }

# # Shutdown route
# # route[SHUTDOWN] {
# xlog("L_INFO", "Kamailio SBC shutting down\n");
# }
